<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Bird Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            background-color: #87ceeb; /* Sky blue background */
            border: 8px solid #4a5568;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background-color: transparent;
        }

        /* Responsive styles */
        @media (max-width: 640px) {
            .game-container {
                width: 95vw;
                height: 70vh;
                border-radius: 1rem;
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

    <div class="game-container w-[800px] h-[600px]">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // Adjust canvas size to fit container on load and resize
            const resizeCanvas = () => {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            };

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Player properties
            const player = {
                x: canvas.width / 2,
                y: canvas.height - 50,
                radius: 25,
                color: '#BFFF33', // Slightly yellower neon greenish
                speed: 5,
                velocity: { x: 0, y: 0 },
                rotation: 0,
                rollingSpeed: 0.1,
                gravity: 0.5,
                jumpPower: -10,
                isGrounded: false,
                isFlapping: false,
                flapTimer: 0,
            };

            // Array to hold other birds
            const otherBirds = [];
            const maxBirds = 5;

            // Generate a random color
            const getRandomColor = () => {
                const colors = ['#FF5733', '#33FFBD', '#336BFF', '#FF33F5', '#F5FF33'];
                return colors[Math.floor(Math.random() * colors.length)];
            };
            
            // Function to darken a hex color by a percentage
            const darkenColor = (hex, percent) => {
                let r = parseInt(hex.slice(1, 3), 16);
                let g = parseInt(hex.slice(3, 5), 16);
                let b = parseInt(hex.slice(5, 7), 16);

                r = Math.floor(r * (1 - percent / 100));
                g = Math.floor(g * (1 - percent / 100));
                b = Math.floor(b * (1 - percent / 100));

                const toHex = (c) => ('0' + c.toString(16)).slice(-2);
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            };

            // Bird class for other birds
            class Bird {
                constructor(x, y, radius, color) {
                    this.x = x;
                    this.y = y;
                    this.radius = radius;
                    this.color = color;
                    this.beakColor = darkenColor(color, 60);
                    this.velocity = { x: (Math.random() - 0.5) * 4, y: 0 };
                    this.gravity = 0.5;
                    this.jumpPower = -8;
                    this.isGrounded = false;
                    this.isFlapping = false;
                    this.flapTimer = 0;
                }

                update() {
                    this.velocity.y += this.gravity;
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;

                    // Bounce off walls
                    if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                        this.velocity.x *= -1;
                    }

                    // Ground collision and random jump
                    if (this.y + this.radius > canvas.height - 20) {
                        this.y = canvas.height - 20 - this.radius;
                        this.velocity.y = 0;
                        this.isGrounded = true;
                        if (Math.random() < 0.02) { // 2% chance to jump
                            this.velocity.y = this.jumpPower;
                            this.isGrounded = false;
                            this.isFlapping = true;
                            this.flapTimer = 10;
                        }
                    }
                    if (this.flapTimer > 0) {
                        this.flapTimer--;
                        if (this.flapTimer === 0) {
                            this.isFlapping = false;
                        }
                    }
                }

                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);

                    // Wings
                    if (this.isFlapping) {
                        const wingAngle = Math.PI / 8; // Rotate wings up slightly
                        // Right wing
                        ctx.save();
                        ctx.rotate(wingAngle);
                        ctx.beginPath();
                        ctx.moveTo(this.radius * 0.7, 0);
                        ctx.lineTo(this.radius * 1.5, -this.radius * 0.8);
                        ctx.lineTo(this.radius * 1.5, this.radius * 0.8);
                        ctx.fillStyle = this.color;
                        ctx.fill();
                        ctx.restore();
                        // Left wing
                        ctx.save();
                        ctx.rotate(-wingAngle);
                        ctx.beginPath();
                        ctx.moveTo(-this.radius * 0.7, 0);
                        ctx.lineTo(-this.radius * 1.5, -this.radius * 0.8);
                        ctx.lineTo(-this.radius * 1.5, this.radius * 0.8);
                        ctx.fillStyle = this.color;
                        ctx.fill();
                        ctx.restore();
                    }

                    // Main body (circle)
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.closePath();

                    // Eyes (less squinty lines)
                    ctx.beginPath();
                    ctx.moveTo(-10, -8);
                    ctx.lineTo(-2, -5);
                    ctx.moveTo(2, -5);
                    ctx.lineTo(10, -8);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.closePath();
                    
                    // Beak (upside-down triangle)
                    ctx.beginPath();
                    ctx.moveTo(-8, -6); // Left point
                    ctx.lineTo(8, -6);  // Right point
                    ctx.lineTo(0, 4);    // Bottom point
                    ctx.fillStyle = this.beakColor;
                    ctx.fill();
                    ctx.closePath();
                    
                    ctx.restore();
                }
            }

            // Create new birds
            const createNewBird = () => {
                if (otherBirds.length < maxBirds) {
                    const newBird = new Bird(
                        Math.random() * (canvas.width - 50) + 25,
                        Math.random() * (canvas.height / 2),
                        20,
                        getRandomColor()
                    );
                    otherBirds.push(newBird);
                }
            };
            
            // Periodically add new birds
            setInterval(createNewBird, 5000);

            const drawPlayer = () => {
                const beakColor = darkenColor(player.color, 60);

                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.rotation);

                // Wings
                if (player.isFlapping) {
                    const wingAngle = Math.PI / 8; // Rotate wings up slightly
                    // Right wing
                    ctx.save();
                    ctx.rotate(wingAngle);
                    ctx.beginPath();
                    ctx.moveTo(player.radius * 0.7, 0);
                    ctx.lineTo(player.radius * 1.5, -player.radius * 0.8);
                    ctx.lineTo(player.radius * 1.5, player.radius * 0.8);
                    ctx.fillStyle = player.color;
                    ctx.fill();
                    ctx.restore();
                    // Left wing
                    ctx.save();
                    ctx.rotate(-wingAngle);
                    ctx.beginPath();
                    ctx.moveTo(-player.radius * 0.7, 0);
                    ctx.lineTo(-player.radius * 1.5, -player.radius * 0.8);
                    ctx.lineTo(-player.radius * 1.5, player.radius * 0.8);
                    ctx.fillStyle = player.color;
                    ctx.fill();
                    ctx.restore();
                }

                // Main body (circle)
                ctx.beginPath();
                ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.closePath();

                // Tennis ball lines
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius, -Math.PI / 2, Math.PI / 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, player.radius, Math.PI / 2, 3 * Math.PI / 2);
                ctx.stroke();
                ctx.closePath();
                
                // Eyes (less squinty lines)
                ctx.beginPath();
                ctx.moveTo(-12, -10);
                ctx.lineTo(-4, -7);
                ctx.moveTo(4, -7);
                ctx.lineTo(12, -10);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();
                
                // Beak (upside-down triangle)
                ctx.beginPath();
                ctx.moveTo(-10, -6); // Left point
                ctx.lineTo(10, -6);  // Right point
                ctx.lineTo(0, 4);    // Bottom point
                ctx.fillStyle = beakColor;
                ctx.fill();
                ctx.closePath();

                ctx.restore();
            };

            // Keyboard input
            const keys = {
                a: false,
                d: false,
                space: false
            };

            document.addEventListener('keydown', (e) => {
                if (e.key === 'a' || e.key === 'A') {
                    keys.a = true;
                }
                if (e.key === 'd' || e.key === 'D') {
                    keys.d = true;
                }
                if (e.key === ' ') {
                    keys.space = true;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.key === 'a' || e.key === 'A') {
                    keys.a = false;
                }
                if (e.key === 'd' || e.key === 'D') {
                    keys.d = false;
                }
                if (e.key === ' ') {
                    keys.space = false;
                }
            });

            // Update game state
            const update = () => {
                // Apply gravity
                player.velocity.y += player.gravity;

                // Move left and right
                if (keys.a) {
                    player.velocity.x = -player.speed;
                } else if (keys.d) {
                    player.velocity.x = player.speed;
                } else {
                    // Apply friction to slow down
                    player.velocity.x *= 0.95;
                    if (Math.abs(player.velocity.x) < 0.1) {
                        player.velocity.x = 0;
                    }
                }

                // Jump
                if (keys.space && player.isGrounded) {
                    player.velocity.y = player.jumpPower;
                    player.isGrounded = false;
                    player.isFlapping = true;
                    player.flapTimer = 10;
                }

                // Stop flapping after a short duration
                if (player.flapTimer > 0) {
                    player.flapTimer--;
                    if (player.flapTimer === 0) {
                        player.isFlapping = false;
                    }
                }

                // Update position and rotation
                player.x += player.velocity.x;
                player.rotation += player.velocity.x / (player.radius);

                player.y += player.velocity.y;

                // Handle collisions with canvas boundaries
                // Left and right walls
                if (player.x - player.radius < 0) {
                    player.x = player.radius;
                    player.velocity.x = 0;
                } else if (player.x + player.radius > canvas.width) {
                    player.x = canvas.width - player.radius;
                    player.velocity.x = 0;
                }

                // Ground collision
                if (player.y + player.radius > canvas.height - 20) {
                    player.y = canvas.height - 20 - player.radius;
                    player.velocity.y = 0;
                    player.isGrounded = true;
                }
                
                // Keep the 'ground'
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
            };

            // Main game loop
            const gameLoop = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw ground
                ctx.fillStyle = '#22c55e';
                ctx.fillRect(0, canvas.height - 20, canvas.width, 20);

                update();
                drawPlayer();

                // Update and draw other birds
                otherBirds.forEach(bird => {
                    bird.update();
                    bird.draw();
                });

                requestAnimationFrame(gameLoop);
            };

            // Start the game loop
            gameLoop();
        });
    </script>
</body>
</html>
