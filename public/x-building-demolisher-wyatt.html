<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Demolition Physics Game</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        /* Custom styles for the game environment */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            display: flex;
            flex-direction: column;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        #game-container {
            flex-grow: 1; 
            position: relative;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <div id="controls" class="p-4 bg-gray-900 border-b border-gray-700 flex justify-center space-x-4 z-10">
        <button id="explode-button" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-xl transition duration-150 transform hover:scale-105 active:scale-95 text-xl tracking-wider">
            üí• BOOM!
        </button>
        <button id="wrecking-ball-button" class="px-6 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded-lg shadow-xl transition duration-150 transform hover:scale-105 active:scale-95 text-xl tracking-wider">
            üèóÔ∏è Wrecking Ball
        </button>
        <button id="reset-button" class="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow-xl transition duration-150 transform hover:scale-105 active:scale-95">
            Reset Building
        </button>
    </div>
    
    <div id="score-counter" class="absolute top-4 left-4 p-3 bg-gray-900 bg-opacity-80 border border-gray-700 rounded-xl text-base font-mono shadow-2xl z-20 space-y-1">
        <div>Blocks Destroyed: <span id="score-value" class="text-yellow-400 font-extrabold">0</span></div>
        <div>Total Blocks: <span id="total-blocks-value" class="text-green-400 font-extrabold">0</span></div>
    </div>

    <div id="game-container"></div>

    <script>
        // Global variables for Three.js and Cannon.js
        let scene, camera, renderer, controls;
        let world;
        // Each piece now stores mesh, body, and initialPos
        let pieces = []; 
        let isExploded = false; 
        let lastTime;
        // Global variables for physics materials
        let blockMaterial, groundMaterial; 

        // Score Variables
        let score = 0;
        let totalBlocks = 0; // Tracks the total number of blocks in the current structure
        let blocksScored = new Set(); // To ensure blocks are only counted once
        const SCORE_THRESHOLD_DISTANCE_SQ = 1.0 * 1.0; // Check distance greater than 1 block unit (squared)

        // Wrecking Ball Variables
        let wreckingBallMesh = null;
        let wreckingBallBody = null;
        let cableMesh = null;
        
        // Kinematic swing variables
        let wreckingBallAnchor;
        let swingTime = 0; 
        const SWING_MAX_ANGLE = Math.PI / 4; 
        const SWING_SPEED = 1.0; 

        // Dynamic Configuration variables
        let currentNumFloors = 10;
        let currentBlocksX = 5; // Blocks in X direction
        let currentBlocksZ = 5; // Blocks in Z direction
        let currentBuildingCenterY = 5;
        let buildingDimensions = { width: 0, depth: 0 }; 

        // Configuration constants
        const TIME_STEP = 1 / 60;
        const MAX_SUB_STEPS = 5; 
        const BLOCK_SIZE = 1.0;
        const BLOCK_MASS = 5;
        const EXPLOSION_STRENGTH = 1500;
        const HORIZONTAL_GAP = BLOCK_SIZE * 1.001; 
        
        // Wrecking Ball Constants
        const BALL_RADIUS = 2.0;
        const BALL_MASS = 250;
        const CABLE_LENGTH = 30;

        // Sign configuration
        const SIGN_WIDTH_UNITS = 3;
        // NUDGE_INWARD is no longer used for the roof sign placement, but kept as a reminder
        // const NUDGE_INWARD = 0.05; 
        
        // LIST OF SIGN TEXT
        const SIGN_TEXT_OPTIONS = [
            "Gemini Towers", "bruh", "BUILDING", "Apartment", 
            "Data Center", "Vacant", "Closed", "Logang Inc", 
            "Illia Corp", "Center", "AI Servers", "Cheese Factory", "Cam Corp", "David's House O' Roni", "LOCAL - MALL", "News25", "SHAFTS -Mining Operation", "SODA POP", "MSS -3y", "(Logan Lick Locator 3000) ONLY 2.99"
        ];
        
        // --- Core Functions ---

        /**
         * Creates a Three.js mesh with dynamic canvas text applied as a texture.
         */
        function createSignMesh(text, width, height, depth) {
            const canvas = document.createElement('canvas');
            const textureSize = 512;
            canvas.width = textureSize;
            canvas.height = textureSize * (height / width); 

            const context = canvas.getContext('2d');
            context.fillStyle = '#C0C0C0'; 
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.textAlign = 'center';
            context.fillStyle = '#222222'; 
            context.font = 'Bold ' + (textureSize / 8) + 'px Inter, sans-serif'; 
            context.fillText(text, canvas.width / 2, canvas.height / 2 + (textureSize / 16)); 

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const signGeometry = new THREE.BoxGeometry(width, height, depth);

            // Material 4 (+Z face) gets the sign texture.
            const materials = [
                new THREE.MeshPhongMaterial({ color: 0x555555 }), // +X
                new THREE.MeshPhongMaterial({ color: 0x555555 }), // -X
                new THREE.MeshPhongMaterial({ color: 0x555555 }), // +Y
                new THREE.MeshPhongMaterial({ color: 0x555555 }), // -Y
                new THREE.MeshPhongMaterial({ map: texture, transparent: false }), // +Z (The sign face)
                new THREE.MeshPhongMaterial({ color: 0x404040 }), // -Z (The back face)
            ];

            const mesh = new THREE.Mesh(signGeometry, materials);
            mesh.castShadow = true;
            return mesh;
        }
        
        /**
         * Initializes the Three.js scene, camera, and renderer.
         */
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 15, 20); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, currentBuildingCenterY, 0); 
            controls.update();

            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5); 
            directionalLight.position.set(10, 25, 15);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
        }

        /**
         * Initializes the Cannon.js physics world and materials.
         */
        function initCannon() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 20; 

            blockMaterial = new CANNON.Material('block');
            groundMaterial = new CANNON.Material('ground');

            // Contact Material 1: Block-Ground 
            world.addContactMaterial(new CANNON.ContactMaterial(groundMaterial, blockMaterial, {
                friction: 2.0, restitution: 0.01, contactEquationStiffness: 1e8, contactEquationRelaxation: 3 
            }));

            // Contact Material 2: Block-Block 
            world.addContactMaterial(new CANNON.ContactMaterial(blockMaterial, blockMaterial, {
                friction: 1.5, restitution: 0.01, contactEquationStiffness: 1e8, contactEquationRelaxation: 3
            }));
        }

        /**
         * Creates the ground plane in both physics and graphics.
         */
        function createGround() {
            // Cannon.js Ground
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0, shape: groundShape, material: groundMaterial });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            // Three.js Ground
            const groundMaterialMesh = new THREE.MeshPhongMaterial({ color: 0x4a4a4a, side: THREE.DoubleSide });
            const groundMesh = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), groundMaterialMesh); 
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
        }

        /**
         * Creates the stacked building structure.
         */
        function createBuilding() {
            // Clear previous pieces if any
            pieces.forEach(p => {
                world.removeBody(p.body);
                scene.remove(p.mesh);
                if (p.mesh.geometry) p.mesh.geometry.dispose();
                if (p.mesh.material) {
                    if (Array.isArray(p.mesh.material)) {
                        p.mesh.material.forEach(m => m.dispose());
                    } else {
                        p.mesh.material.dispose();
                    }
                }
            });
            pieces = [];
            
            // --- Determine Sign Text and Themed Mode --- // MODIFIED: Moved up for conditional coloring
            const randomText = SIGN_TEXT_OPTIONS[Math.floor(Math.random() * SIGN_TEXT_OPTIONS.length)];
            const isCheeseFactory = randomText === "Cheese Factory";
            
            // High-Rise Configuration (e.g., 5x5 base, 8-15 floors)
            currentNumFloors = Math.floor(Math.random() * (15 - 8 + 1)) + 8; // 8 to 15 floors
            const baseN = Math.floor(Math.random() * (6 - 4 + 1)) + 4; // 4 to 6 blocks wide base
            currentBlocksX = baseN;
            currentBlocksZ = baseN;
            console.log(`Generated Tower: ${currentBlocksX}x${currentBlocksZ} base, ${currentNumFloors} floors. Sign: ${randomText}`);
            
            const Nx = currentBlocksX;
            const Nz = currentBlocksZ;
            
            currentBuildingCenterY = (currentNumFloors * BLOCK_SIZE) / 2;
            
            buildingDimensions.width = Nx * HORIZONTAL_GAP;
            buildingDimensions.depth = Nz * HORIZONTAL_GAP;

            controls.target.set(0, currentBuildingCenterY, 0); 
            controls.update();
            
            // Shapes and Geometries for SMALL blocks
            const halfExtents = new CANNON.Vec3(BLOCK_SIZE / 2, BLOCK_SIZE / 2, BLOCK_SIZE / 2);
            const boxShape = new CANNON.Box(halfExtents);
            const boxGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            const baseHue = Math.random(); 
            const materialTemplate = new THREE.MeshPhongMaterial({ shininess: 30 });
            // Solid floor material (remains dark gray regardless of theme)
            const thickFloorMaterial = new THREE.MeshPhongMaterial({ color: 0x5a5a5a, shininess: 50, emissive: 0x111111 }); 

            // Cheese Factory Theme Colors
            const CHEESE_YELLOW = 0xFFFF33; // Bright yellow for interior
            const EXTERIOR_GRAY_1 = 0xAAAAAA; // Light Gray
            const EXTERIOR_GRAY_2 = 0x666666; // Dark Gray

            // Offset to the center of the outer blocks
            const centerOffsetX = (Nx - 1) * HORIZONTAL_GAP / 2; // Used for block positioning
            const centerOffsetZ = (Nz - 1) * HORIZONTAL_GAP / 2; // Used for block positioning
            
            // Distance from origin to the outer face of the building (Used for sign placement)
            const wallFaceX = (Nx * HORIZONTAL_GAP) / 2; 
            const wallFaceZ = (Nz * HORIZONTAL_GAP) / 2; 
            
            // --- REINFORCED FLOOR DIMENSIONS ---
            const minN = Math.min(Nx, Nz);
            const REINFORCED_WIDTH_UNITS = minN >= 3 ? minN - 2 : 0;
            const REINFORCED_WIDTH = REINFORCED_WIDTH_UNITS * HORIZONTAL_GAP; 

            // Shapes for reinforced pieces (same as before)
            const singleReinforcedExtents = new CANNON.Vec3(REINFORCED_WIDTH / 2, BLOCK_SIZE / 2, REINFORCED_WIDTH / 2);
            const singleReinforcedShape = new CANNON.Box(singleReinforcedExtents);
            const singleReinforcedGeometry = new THREE.BoxGeometry(REINFORCED_WIDTH, BLOCK_SIZE, REINFORCED_WIDTH);
            const HALF_SPLIT_WIDTH = REINFORCED_WIDTH / 2;
            const halfSplitExtents = new CANNON.Vec3(REINFORCED_WIDTH / 2, BLOCK_SIZE / 2, HALF_SPLIT_WIDTH / 2);
            const halfSplitShape = new CANNON.Box(halfSplitExtents);
            const halfSplitGeometry = new THREE.BoxGeometry(REINFORCED_WIDTH, BLOCK_SIZE, HALF_SPLIT_WIDTH);


            // --- 2. CREATE MAIN BUILDING BLOCKS ---
            for (let floor = 0; floor < currentNumFloors; floor++) {
                
                // Thick floors every 3 levels AND on the very top floor (for full roof coverage)
                const isThickFloorLayer = (floor === currentNumFloors - 1) || ((floor > 0) && ((floor + 1) % 3 === 0));
                const posY = (floor * BLOCK_SIZE) + BLOCK_SIZE / 2;

                // --- A. CREATE REINFORCED FLOOR SLAB PIECE(S) ---
                if (isThickFloorLayer && REINFORCED_WIDTH_UNITS > 0) {
                    const slabY = posY;

                    if (Nx === Nz) { // Square base: single central reinforced block
                        const body = new CANNON.Body({ mass: 0, shape: singleReinforcedShape, material: blockMaterial });
                        body.position.set(0, slabY, 0);
                        world.addBody(body);
                        
                        const mesh = new THREE.Mesh(singleReinforcedGeometry, thickFloorMaterial.clone());
                        mesh.position.copy(body.position);
                        mesh.castShadow = true;
                        scene.add(mesh);
                        pieces.push({ mesh: mesh, body: body, initialPos: { x: 0, y: slabY, z: 0 } });

                    } else { // Rectangular base: two split reinforced blocks (for stability)
                        
                        // Check orientation to determine split axis (split along the shorter axis for stability)
                        const isSplitX = Nx > Nz;
                        const splitOffset = isSplitX ? centerOffsetZ : centerOffsetX;

                        // Piece 1: split left/back
                        let pos1X = isSplitX ? 0 : -(splitOffset / 2);
                        let pos1Z = isSplitX ? -(splitOffset / 2) : 0;
                        let body1 = new CANNON.Body({ mass: 0, shape: halfSplitShape, material: blockMaterial });
                        body1.position.set(pos1X, slabY, pos1Z);
                        body1.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), isSplitX ? 0 : Math.PI / 2);
                        world.addBody(body1);
                        
                        const mesh1 = new THREE.Mesh(halfSplitGeometry, thickFloorMaterial.clone());
                        mesh1.position.copy(body1.position);
                        mesh1.quaternion.copy(body1.quaternion);
                        mesh1.castShadow = true;
                        scene.add(mesh1);
                        pieces.push({ mesh: mesh1, body: body1, initialPos: { x: pos1X, y: slabY, z: pos1Z } });

                        // Piece 2: split right/front
                        let pos2X = isSplitX ? 0 : (splitOffset / 2);
                        let pos2Z = isSplitX ? (splitOffset / 2) : 0;
                        let body2 = new CANNON.Body({ mass: 0, shape: halfSplitShape, material: blockMaterial });
                        body2.position.set(pos2X, slabY, pos2Z);
                        body2.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), isSplitX ? 0 : Math.PI / 2);
                        world.addBody(body2);
                        
                        const mesh2 = new THREE.Mesh(halfSplitGeometry, thickFloorMaterial.clone());
                        mesh2.position.copy(body2.position);
                        mesh2.quaternion.copy(body2.quaternion);
                        mesh2.castShadow = true;
                        scene.add(mesh2);
                        pieces.push({ mesh: mesh2, body: body2, initialPos: { x: pos2X, y: slabY, z: pos2Z } });
                    }
                }

                // --- B. CREATE INDIVIDUAL WALL BLOCKS (SOLID) ---
                for (let x = 0; x < Nx; x++) {
                    for (let z = 0; z < Nz; z++) {
                        
                        // Skip internal blocks on thick floors (they are covered by the slab)
                        const isInternalX = x > 0 && x < Nx - 1;
                        const isInternalZ = z > 0 && z < Nz - 1;
                        
                        // Check if this block is an exterior wall block (on the perimeter)
                        const isExteriorBlock = (x === 0 || x === Nx - 1 || z === 0 || z === Nz - 1); 

                        if (isThickFloorLayer && REINFORCED_WIDTH_UNITS > 0 && isInternalX && isInternalZ) continue;
                        
                        const posX = (x * HORIZONTAL_GAP) - centerOffsetX;
                        const posZ = (z * HORIZONTAL_GAP) - centerOffsetZ;
                        
                        const body = new CANNON.Body({
                            mass: 0, 
                            shape: boxShape,
                            linearDamping: 0.15, 
                            angularDamping: 0.15, 
                            material: blockMaterial 
                        });
                        
                        body.position.set(posX, posY, posZ);
                        world.addBody(body);

                        // --- CONDITIONAL COLOR APPLICATION (MODIFIED) ---
                        const meshMaterial = materialTemplate.clone();
                        
                        if (isCheeseFactory) {
                            if (isExteriorBlock) {
                                // Gray/Dark Gray Exterior (Alternating by floor)
                                meshMaterial.color.set(floor % 2 === 0 ? EXTERIOR_GRAY_1 : EXTERIOR_GRAY_2);
                            } else {
                                // Yellow Interior (All non-exterior, non-slab blocks)
                                meshMaterial.color.set(CHEESE_YELLOW);
                            }
                        } else {
                            // Original randomized color logic
                            meshMaterial.color.setHSL(baseHue, 0.7, floor % 2 === 0 ? 0.65 : 0.55);
                        }
                        // --- END CONDITIONAL COLOR APPLICATION ---

                        const mesh = new THREE.Mesh(boxGeometry, meshMaterial);
                        mesh.position.copy(body.position);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        scene.add(mesh);

                        // Store initial position for scoring
                        const initialPos = { x: posX, y: posY, z: posZ }; 
                        pieces.push({ mesh, body, initialPos });
                    }
                }
            }
            
            // --- 3. CREATE ROOF BILLBOARD SIGN (Dynamic placement and text) ---
            const signWorldWidth = SIGN_WIDTH_UNITS * HORIZONTAL_GAP;
            const signWorldHeight = (Math.floor(Math.random() * 2) + 1) * BLOCK_SIZE;
            const signWorldDepth = BLOCK_SIZE / 4;
            
            // NEW Y POSITION: Place the center of the sign (signWorldHeight / 2) above the top surface (currentNumFloors * BLOCK_SIZE)
            const buildingTopY = currentNumFloors * BLOCK_SIZE;
            const signY = buildingTopY + signWorldHeight / 2; 
            
            let signPosX = 0;
            let signPosZ = 0;
            let signRotation = 0; // Y-axis rotation
            
            // randomText is already defined at the start of the function

            // Randomly choose an edge (X or Z) to place the sign
            if (Math.random() < 0.5) { 
                // Place on the Z-axis faces (Front/Back)
                
                if (Math.random() < 0.5) { 
                    // +Z face (Front)
                    signPosZ = wallFaceZ - (signWorldDepth / 2); // Flush with outer edge
                    signRotation = 0; // Texture (+Z local) points +Z global (Outwards)
                } else { 
                    // -Z face (Back)
                    signPosZ = -wallFaceZ + (signWorldDepth / 2); // Flush with outer edge
                    signRotation = Math.PI; // Flips texture (+Z local) to point -Z global (Outwards)
                }
                // Center sign horizontally
                signPosX = 0;

            } else { 
                // Place on the X-axis faces (Right/Left)
                
                if (Math.random() < 0.5) { 
                    // +X face (Right)
                    signPosX = wallFaceX - (signWorldDepth / 2); // Flush with outer edge
                    signRotation = Math.PI / 2; // Rotates texture (+Z local) to point +X global (Outwards)
                } else { 
                    // -X face (Left)
                    signPosX = -wallFaceX + (signWorldDepth / 2); // Flush with outer edge
                    signRotation = -Math.PI / 2; // Rotates texture (+Z local) to point -X global (Outwards)
                }
                // Center sign depth-wise (Z-axis)
                signPosZ = 0;
            }

            const signMesh = createSignMesh(randomText, signWorldWidth, signWorldHeight, signWorldDepth);
            signMesh.position.set(signPosX, signY, signPosZ); 
            signMesh.rotation.y = signRotation; 
            scene.add(signMesh);

            const signHalfExtents = new CANNON.Vec3(signWorldWidth / 2, signWorldHeight / 2, signWorldDepth / 2);
            const signShape = new CANNON.Box(signHalfExtents);

            const signBody = new CANNON.Body({
                mass: 0, 
                shape: signShape,
                material: blockMaterial,
                position: new CANNON.Vec3(signPosX, signY, signPosZ)
            });
            signBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), signRotation);
            world.addBody(signBody);
            pieces.push({ mesh: signMesh, body: signBody, initialPos: { x: signPosX, y: signY, z: signPosZ } });

            
            // --- 4. FINALIZE: Update total block count ---
            totalBlocks = pieces.length;
            document.getElementById('total-blocks-value').textContent = totalBlocks;
        }

        /**
         * Gives all building pieces dynamic mass and makes them active in the physics simulation.
         */
        function activateBuildingPhysics() {
            // Only activate if not already exploded/activated
            if (isExploded) return;
            isExploded = true;
            document.getElementById('explode-button').disabled = true;
            document.getElementById('wrecking-ball-button').disabled = true;

            pieces.forEach(({ body }) => {
                // Ensure the wrecking ball doesn't set its own mass to BLOCK_MASS
                if (body.type !== CANNON.Body.KINEMATIC && body.mass === 0) { 
                    body.mass = BLOCK_MASS;
                    body.type = CANNON.Body.DYNAMIC; 
                    body.updateMassProperties(); 
                }
            });
            console.log("Building physics activated (blocks given mass).");
        }

        /**
         * Applies the explosive impulse force (used by the BOOM! button).
         */
        function applyExplosionForce() {
            const buildingTotalHeight = currentNumFloors * BLOCK_SIZE;
            let explosionY;

            if (Math.random() < 0.5) {
                const heightFactor = 0.5 + Math.random() * 0.4; 
                explosionY = buildingTotalHeight * heightFactor;
                console.log(`Explosion: High (${(heightFactor * 100).toFixed(0)}% height)`);
            } else {
                explosionY = buildingTotalHeight * 0.25; 
                console.log("Explosion: Low (25% height)");
            }
            
            const explosionCenter = new THREE.Vector3(0, explosionY, 0); 

            pieces.forEach(({ body }) => {
                // Only apply to dynamic/static building pieces
                if (body.type === CANNON.Body.STATIC || body.mass === 0) return; 

                const bodyPos = new THREE.Vector3(body.position.x, body.position.y, body.position.z);
                
                const direction = bodyPos.clone().sub(explosionCenter).normalize();
                const distance = bodyPos.distanceTo(explosionCenter);
                const forceMagnitude = EXPLOSION_STRENGTH / (distance * distance + 10); 

                const impulse = new CANNON.Vec3(
                    direction.x * forceMagnitude,
                    direction.y * forceMagnitude * 1.5, 
                    direction.z * forceMagnitude
                );

                body.applyImpulse(impulse, body.position);
                const torque = new CANNON.Vec3(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50
                );
                body.torque = torque;
            });
        }


        /**
         * Step 1 of the explosion: Activates physics then applies force after a delay.
         */
        function createExplosion() {
            if (isExploded) return;
            activateBuildingPhysics();
            setTimeout(applyExplosionForce, 50); 
        }
        
        /**
         * Applies a strong impact force from the wrecking ball to nearby blocks.
         */
        function applyWreckingBallImpactForce(impactPosition) {
            const impactPoint = new THREE.Vector3().copy(impactPosition);
            // Use a large impulse to simulate the hit, scaled by the ball's mass
            const impactStrength = BALL_MASS * 50; 
            const activationRadius = BALL_RADIUS * 2;

            pieces.forEach(({ body }) => {
                // Only affect dynamic pieces
                if (body.type === CANNON.Body.STATIC || body.mass === 0) return; 
                
                const bodyPos = new THREE.Vector3(body.position.x, body.position.y, body.position.z);
                const distance = bodyPos.distanceTo(impactPoint);

                if (distance < activationRadius) {
                    const direction = bodyPos.clone().sub(impactPoint).normalize();
                    // Inverse distance falloff for force
                    const forceMagnitude = impactStrength / (distance + 1); 

                    // Direction of impulse should push blocks away from the impact point
                    const impulse = new CANNON.Vec3(
                        direction.x * forceMagnitude * 0.5, 
                        direction.y * forceMagnitude, 
                        direction.z * forceMagnitude * 0.5
                    );

                    body.applyImpulse(impulse, body.position);
                }
            });
        }

        /**
         * Creates and launches the wrecking ball with kinematic movement.
         */
        function createWreckingBall() {
            if (wreckingBallBody) return; // Only one ball at a time

            // 1. Choose Anchor Point (high and far away)
            const angleOffset = Math.PI / 4; 
            const buildingMaxDimension = Math.max(buildingDimensions.width, buildingDimensions.depth);
            const anchorDistance = buildingMaxDimension * 2.5; 
            
            // Anchor must be high enough above the ground
            const anchorY = currentNumFloors * BLOCK_SIZE * 3.0; 
            
            const anchorX = Math.cos(angleOffset) * anchorDistance;
            const anchorZ = Math.sin(angleOffset) * anchorDistance;

            // Store the fixed anchor point
            wreckingBallAnchor = new CANNON.Vec3(anchorX, anchorY, anchorZ);
            
            // Calculate starting position
            const startAngle = SWING_MAX_ANGLE; 
            const cableRotAxis = new THREE.Vector3(0, 1, 0).cross(new THREE.Vector3(anchorX, 0, anchorZ)).normalize();
            const startRotation = new THREE.Quaternion().setFromAxisAngle(cableRotAxis, startAngle);
            let cableVec = new THREE.Vector3(0, -CABLE_LENGTH, 0); 
            cableVec.applyQuaternion(startRotation);
            const ballPosition = new CANNON.Vec3(anchorX + cableVec.x, anchorY + cableVec.y, anchorZ + cableVec.z);


            // 2. Create Physics Body (Kinematic type)
            const ballShape = new CANNON.Sphere(BALL_RADIUS);
            wreckingBallBody = new CANNON.Body({
                mass: BALL_MASS, 
                shape: ballShape,
                position: ballPosition,
                type: CANNON.Body.KINEMATIC, 
                linearDamping: 0.05,
                angularDamping: 0.1,
                material: blockMaterial 
            });
            world.addBody(wreckingBallBody);

            // 3. Create Graphics (Ball Mesh)
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({ color: 0x888888, shininess: 100 });
            wreckingBallMesh = new THREE.Mesh(ballGeometry, ballMaterial);
            wreckingBallMesh.castShadow = true;
            scene.add(wreckingBallMesh);

            // 4. Create Graphics (Cable Mesh - simple line)
            const material = new THREE.LineBasicMaterial({ color: 0xcccccc, linewidth: 3 });
            const geometry = new THREE.BufferGeometry();
            cableMesh = new THREE.Line(geometry, material);
            scene.add(cableMesh);
            
            // Reset swing time for clean start
            swingTime = 0; 
            
            console.log("Kinematic wrecking ball created and ready to swing.");
        }


        /**
         * Removes the wrecking ball components.
         */
        function removeWreckingBall() {
            if (wreckingBallBody) {
                world.removeBody(wreckingBallBody);
                scene.remove(wreckingBallMesh);
                wreckingBallBody = null;
                wreckingBallMesh = null;
            }
            if (cableMesh) {
                scene.remove(cableMesh);
                cableMesh = null;
            }
        }


        /**
         * Resets the game by recreating the building and environment.
         */
        function resetGame() {
            isExploded = false;
            document.getElementById('explode-button').disabled = false;
            document.getElementById('wrecking-ball-button').disabled = false;
            
            // Reset Score
            score = 0;
            blocksScored.clear();
            document.getElementById('score-value').textContent = '0';
            
            // Reset Total Blocks display
            totalBlocks = 0; 
            document.getElementById('total-blocks-value').textContent = '0'; 
            
            removeWreckingBall(); 

            // Clear previous Three.js meshes and dispose of their memory
            pieces.forEach(p => {
                world.removeBody(p.body); 
                scene.remove(p.mesh);
                if (p.mesh.geometry) p.mesh.geometry.dispose();
                if (p.mesh.material) {
                    if (Array.isArray(p.mesh.material)) {
                        p.mesh.material.forEach(m => m.dispose());
                    } else {
                        p.mesh.material.dispose();
                    }
                }
            });
            pieces = []; 

            // Clear ground mesh
            scene.children.forEach(child => {
                if (child.geometry && child.geometry.type === 'PlaneGeometry') {
                    scene.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
            });
            
            createGround(); 
            createBuilding(); 
        }


        /**
         * Main animation loop.
         */
        function animate(time) {
            requestAnimationFrame(animate);

            if (lastTime !== undefined) {
                const dt = (time - lastTime) / 1000;
                // Update the physics world
                world.step(TIME_STEP, dt, MAX_SUB_STEPS); 

                // Synchronize Three.js meshes with Cannon.js bodies
                pieces.forEach(({ mesh, body }) => {
                    mesh.position.copy(body.position);
                    mesh.quaternion.copy(body.quaternion);
                });
                
                // Score Calculation - Only count if physics is active
                if (isExploded) {
                    let currentScore = score;
                    
                    pieces.forEach((piece) => {
                        const { body, initialPos } = piece;

                        // Use the body's unique ID to track scored blocks
                        const blockId = body.id;
                        if (blocksScored.has(blockId)) {
                            return; 
                        }

                        // Calculate distance from original position: d^2 = dx^2 + dy^2 + dz^2
                        const dx = body.position.x - initialPos.x;
                        const dy = body.position.y - initialPos.y;
                        const dz = body.position.z - initialPos.z;
                        const distanceSq = dx * dx + dy * dy + dz * dz;

                        if (distanceSq > SCORE_THRESHOLD_DISTANCE_SQ) {
                            score++;
                            blocksScored.add(blockId);
                        }
                    });
                    
                    // Update score display only if score has changed
                    if (currentScore !== score) {
                        document.getElementById('score-value').textContent = score;
                    }
                }

                // Wrecking Ball Logic (Kinematic Swing)
                if (wreckingBallBody) {
                    swingTime += dt * SWING_SPEED;
                    
                    // 1. Calculate the current swing angle using a sine wave
                    const currentAngle = SWING_MAX_ANGLE * Math.sin(swingTime);

                    // 2. Determine the rotation axis
                    const anchorTHREE = new THREE.Vector3().copy(wreckingBallAnchor);
                    const centerFloorTHREE = new THREE.Vector3(0, 0, 0);
                    
                    const cableDirH = anchorTHREE.clone().sub(centerFloorTHREE).normalize();
                    cableDirH.y = 0; 
                    const rotationAxis = new THREE.Vector3(0, 1, 0).cross(cableDirH).normalize();
                    
                    // 3. Create a Quaternion to represent the current swing rotation
                    const rotation = new THREE.Quaternion().setFromAxisAngle(rotationAxis, currentAngle);

                    // 4. Calculate new ball position
                    let cableVec = new THREE.Vector3(0, -CABLE_LENGTH, 0); 
                    cableVec.applyQuaternion(rotation);
                    const newBallPosition = anchorTHREE.clone().add(cableVec);

                    // 5. Kinematically update the Cannon body
                    wreckingBallBody.position.copy(newBallPosition);
                    wreckingBallBody.quaternion.set(0, 0, 0, 1); 

                    // 6. Update mesh and cable graphics
                    wreckingBallMesh.position.copy(newBallPosition);
                    wreckingBallMesh.quaternion.copy(wreckingBallBody.quaternion);

                    if (cableMesh) {
                        const positions = new Float32Array([
                            anchorTHREE.x, anchorTHREE.y, anchorTHREE.z, 
                            newBallPosition.x, newBallPosition.y, newBallPosition.z 
                        ]);
                        cableMesh.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        cableMesh.geometry.attributes.position.needsUpdate = true;
                    }
                    
                    // 7. Collision Detection / Building Activation
                    if (!isExploded) {
                        const ballPos2D = new THREE.Vector2(newBallPosition.x, newBallPosition.z);
                        const center2D = new THREE.Vector2(0, 0);
                        const distance2D = ballPos2D.distanceTo(center2D);
                        
                        const buildingBoundary = Math.max(buildingDimensions.width, buildingDimensions.depth) / 2 + BALL_RADIUS * 1.5; 

                        if (distance2D < buildingBoundary) {
                            activateBuildingPhysics();
                            console.log("Wrecking ball struck the building! Activating physics.");
                            applyWreckingBallImpactForce(newBallPosition); 
                        }
                    }
                }
            }
            lastTime = time;

            controls.update(); 
            renderer.render(scene, camera);
        }

        /**
         * Handles window resizing to maintain responsiveness.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Initialization function called on window load.
         */
        window.onload = function () {
            // Setup
            initThree();
            initCannon();
            // Initial calls for ground and building
            createGround(); 
            createBuilding(); 

            // Event Listeners
            document.getElementById('explode-button').addEventListener('click', createExplosion);
            document.getElementById('wrecking-ball-button').addEventListener('click', createWreckingBall);
            document.getElementById('reset-button').addEventListener('click', resetGame);
            window.addEventListener('resize', onWindowResize);

            // Start the game loop
            animate();
        };
    </script>

</body>
</html>
